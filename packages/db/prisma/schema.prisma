generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id              String    @id @default(uuid()) @db.Uuid
  email           String    @unique
  password        String    @map("password_hash")
  username        String
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  // Relations
  wallets        Wallet[]
  //positions      Positions[]
  orders         Order[]

  @@map("users")
}

// model Position {
//   id               String         @id @default(uuid()) @db.Uuid
//   userId           String         @map("user_id") @db.Uuid
//   symbol           Symbol
//   side             Side
//   status           PositionStatus @default(OPEN)
  
//   quantity         BigInt
//   quantityDecimals Int            @default(8) @map("quantity_decimals")
  
//   entryPrice       BigInt         @map("entry_price")
//   exitPrice        BigInt?        @map("exit_price")
//   priceDecimals    Int            @default(2) @map("price_decimals")
  
//   leverage         Int            @default(1)
//   marginUsed       BigInt         @map("margin_used")
//   marginDecimals   Int            @default(2) @map("margin_decimals")
  
//   takeProfitPrice  BigInt?        @map("take_profit_price")
//   stopLossPrice    BigInt?        @map("stop_loss_price")
  
//   realizedPnl      BigInt?        @map("realized_pnl")
//   pnlDecimals      Int            @default(2) @map("pnl_decimals")
  
//   closeReason      CloseReason?   @map("close_reason")
//   createdAt        DateTime       @default(now()) @map("created_at")
//   updatedAt        DateTime       @updatedAt @map("updated_at")
//   closedAt         DateTime?      @map("closed_at")
  
//   user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
//   orders Order[]

//   @@index([userId, status])
//   @@index([symbol, status])
//   @@map("positions")
// }


model Wallet {
  id              String   @id @default(uuid()) @db.Uuid
  userId          String   @map("user_id") @db.Uuid
  symbol          Symbol
  balanceRaw      Int      @map("balance_raw") 
  balanceDecimals Int      @default(8) @map("balance_decimals") 
  
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Constraints & Indexes
  @@unique([userId, symbol])
  @@index([symbol])
  @@map("assets")
}

model Order {
  id                String       @id @default(uuid()) @db.Uuid
  userId            String       @map("user_id") @db.Uuid
  symbol            Symbol       // Add this - what asset is being traded
  side              OrderSide          @map("side")
  status            OrderStatus  @default(OPEN)
  
  // Quantities (stored as integers, use decimals for display)
  quantity          Int          @map("quantity")
  quantityDecimals  Int          @default(2) @map("quantity_decimals")
  
  // Prices (stored as integers to avoid floating point issues)
  openPrice         Int          @map("open_price")
  closePrice        Int?         @map("close_price")
  priceDecimals     Int          @default(2) @map("price_decimals")
  
  // Risk Management
  leverage          Int          @default(1)
  margin   Int                   @map("margin_required")
  takeProfitPrice   Int?         @map("take_profit_price")
  stopLossPrice     Int?         @map("stop_loss_price")
  
  // P&L (Profit and Loss)
  Pnl               Int?         @map("realized_pnl") // null if open
  
  // Lifecycle
  closeReason       CloseReason? @map("close_reason")
  createdAt         DateTime     @default(now()) @map("created_at")
  updatedAt         DateTime     @updatedAt @map("updated_at")
  closedAt          DateTime?    @map("closed_at")
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Constraints & Indexes
  @@index([userId, status])
  @@index([status, createdAt])
  @@index([symbol, status])
  @@map("orders")
}

// Enums with proper naming
enum Symbol {
  USDC
  BTC
  SOL
  ETH  // Consider making this extensible
  
  @@map("symbol")
}

enum OrderSide {
  LONG
  SHORT
  
  @@map("order_side")
}

enum OrderStatus {
  OPEN
  CLOSED
  
  @@map("order_status")
}

enum CloseReason {
  TAKE_PROFIT
  STOP_LOSS
  MANUAL
  LIQUIDATION
  
  @@map("close_reason")
}